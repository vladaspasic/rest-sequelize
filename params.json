{"name":"Rest-sequelize","tagline":"REST Service using Sequelize ORM","body":"# rest-sequelize [![Build Status](https://img.shields.io/travis/vladaspasic/rest-sequelize.svg?branch=master)](https://travis-ci.org/vladaspasic/rest-sequelize) [![Coverage Status](https://img.shields.io/coveralls/vladaspasic/rest-sequelize.svg)](https://coveralls.io/r/vladaspasic/rest-sequelize)\r\n\r\nRest Sequelize library is built to provide you with a extendible REST interface that you can use.\r\n\r\n###Installation\r\n\r\n```bash\r\nnpm install rest-sequelize --save\r\n```\r\n\r\n###Introduction\r\n\r\nThis library exposes you a simple Namespace Object containg all the thing you would need. Let quickly through them:\r\n\r\n* RestAdapter\r\n* RestService\r\n* Resolver\r\n* Serializer\r\n* Deserializer\r\n\r\nAll of these classes expose `create` and `extend` methods. It is advised that you instantiate all those classes with `RestAdapter.create()` instead `new RestAdapter()`.\r\n\r\nIn order to create subclasses use `RestAdapter.extend()` method. Keep in mind that if you override a method in the class, you can call its super implementation like so:\r\n\r\n```javascript\r\nvar MyService = RestService.extend({\r\n    init: function() {\r\n        this._super();\r\n    }\r\n});\r\n```\r\n\r\nFor full API docs visit ....\r\n\r\nThis library uses [error-globals](https://github.com/vladaspasic/error-globals) for Error handling, as we can get the `statusCode` property for each error thrown by the library to display an appropriate HTTP status code in the response.\r\n\r\n#### Usage\r\n\r\nTo use this you must first create a `RestAdapter` instance, and pass a `sequelize` property to it. I will not go through how to create a Sequelize instance, you can read this [here](http://docs.sequelizejs.com/en/latest/docs/getting-started/).\r\n\r\n```javascript\r\nvar RestSequelize = require('rest-sequelize');\r\n\r\nvar adapter = RestSequelize.RestAdapter.extend({\r\n   sequelize: sequelize,// your initialized sequelized instance\r\n});\r\n```\r\n\r\nHere we have created a simple `RestAdapter` instance with a `DefaultResolver`. If you wish to use a custom `Resolver` you must create your own. But we will come to that a bit later.\r\n\r\nLets asume that you have already created an sequelize instance, and defined a `User` model. To get a full list of users, you can do something like this.\r\n\r\n```javascript\r\nadapter.find('users').then(function(users) {\r\n    console.log(users);\r\n}, function(error) {\r\n    // your error handling logic\r\n});\r\n\r\n// Or\r\n\r\nadapter.find(sequelize.models.User).then(function(users) {\r\n    console.log(users);\r\n}, function(error) {\r\n    // your error handling logic\r\n});\r\n```\r\n\r\nLet us explain what is going under the hood step by step.\r\n\r\nFirst we will try to resolve the the `Model` using the `modelFor` method in the `RestAdapter`, this method then asks the `Resolver` to find it/resolve it. Resolver then tries to see if a model with a plural name for `users` exists in the the sequelize instance. Or in the second case the Model would be returned as it is already there.\r\n\r\nWhen a model is resolved, we are trying to find a corresponding `RestService` for `users`. In this case there is none as we are using the `DefaultResolver`\r\nto find all modules, so a default `RestService` will be returned.\r\n\r\nThe `RestService` class is where all the communication with the DB occurs. The default one would be sufficent in most cases, but you can always create your own.\r\nHere you could add your custom logic that can be run against the Sequelize ORM.\r\n\r\nThe service will return a model with all his associatations populated, and a count property. The adapter will create a default paging query with `page` property `1` and `size` `30` and default `sort` `updated_at` and `order` `DESC`.\r\n\r\nYou can page a resource like this.\r\n\r\n```javascript\r\nadapter.find('users', {\r\n    page: 2,\r\n    size: 15,\r\n    sort: 'username',\r\n    order: 'asc'\r\n}).then(function(users) {\r\n    console.log(users);\r\n});\r\n```\r\n\r\nWhen a `RestService` finds the models, we are returning to the `RestAdapter` which will then try to find a `Serializer` to serialize the your results to a simple JSON object ready to be flushed to the client.\r\n\r\nLet us now create a new User.\r\n\r\n```javascript\r\nadapter.create('users',{\r\n    username: 'username',\r\n    password: 'pass'\r\n}).then(function(user) {\r\n    console.log(user);\r\n}, function(error) {\r\n    // your error handling logic\r\n});\r\n```\r\n\r\nAgain we will try to resolve the model, but now we are going to see if there is a matching `Deserializer` which will try to deserialize the payload from the method. Deserializer can be usefull if you have wish to add some default values or manipulate them, or some of the keys are differently defined in the Model schema and in your Rest interface.\r\n\r\nAfterwards we resolve a `RestService` that will actually create the Model instance and persist in the DB. The result is the again serialized using the matching `Serializer`.\r\n\r\nWe have now create a new User, lets see if can find him.\r\n\r\n```javascript\r\nadapter.findById('users', 1).then(function(user) {\r\n    console.log(user);\r\n});\r\n```\r\nAnd update it.\r\n\r\n```javascript\r\nadapter.update('users', 1, {\r\n    username: 'new username'\r\n}).then(function(user) {\r\n    console.log(user);\r\n});\r\n\r\n// or\r\n\r\nadapter.update('users', {\r\n    id: 1,\r\n    username: 'new username'\r\n}).then(function(user) {\r\n    console.log(user);\r\n});\r\n```\r\n\r\nMainly the same happens here as well, resolving `Model` -> `Deserializer` -> `RestService` -> `Serializer`. But inside the Service where are trying to see if the model with that ID exists and update it.\r\n\r\nAnd we can delete it\r\n\r\n```javascript\r\nadapter.delete('users', 1).then(function(user) {\r\n    console.log(user);\r\n});\r\n```\r\n\r\n#### Resolver\r\n\r\nAs you could see the `Resolver` is one powerfull tool here as we can resolve to different implementations of the `Service`, `Serializer`, `Deserializer` and `Model` depending on the `name` and `type`.\r\n\r\nTo create your custom resolver you must implement the `resolve` method. Where type can be `services`, `models`, `serializers` or `deserializers`. Maybe you wish to add more types to your Rest interface that could be used by the Adapter.\r\n\r\n```javascript\r\nvar RestSequelize = require('rest-sequelize');\r\n\r\nvar MyResolver = RestSequelize.Resolver.extend({\r\n    resolve: function(type, name) {\r\n        // Your logic\r\n    }\r\n});\r\n```\r\n\r\nAnd we can now add it the `RestAdapter`. Please make sure that you do not pass a\r\ninstance as the resolver is created by the `RestAdapter` which will then pass the `sequelize` property to it.\r\n\r\n```javascript\r\nvar adapter = RestSequelize.RestAdapter.extend({\r\n   sequelize: sequelize,\r\n   Resolver: MyResolver\r\n});\r\n```\r\n\r\n","google":"UA-57430955-2","note":"Don't delete this file! It's used internally to help with page regeneration."}